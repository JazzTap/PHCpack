/* reads a target and start system and then solves the target system,
   using the start system in an artificial-parameter homotopy */

#include <stdio.h>
#include "solcon.h"
#include "phcpack.h"
#include "jump_track.h"
#include "next_track.h"

int prompt_for_precision ( void );
/*
 * DESCRIPTION :
 *   Prompts the user for the level of precision and returns
 *   0 for standard double precision, 1 for double double precision,
 *   and 2 for quad double precision. */

int call_initialize_standard_homotopy ( int *index );
/*
 * DESCRIPTION :
 *   Prepares the containers to initialize the homotopy to track a path
 *   in standard double precision.  Returns in index the number of the
 *   solution in the container selected as start solution. */

int call_initialize_dobldobl_homotopy ( int *index );
/*
 * DESCRIPTION :
 *   Prepares the containers to initialize the homotopy to track a path
 *   in double double precision.  Returns in index the number of the
 *   solution in the container selected as start solution. */

int call_initialize_quaddobl_homotopy ( int *index );
/*
 * DESCRIPTION :
 *   Prepares the containers to initialize the homotopy to track a path
 *   in quad double precision.  Returns in index the number of the
 *   solution in the container selected as start solution. */

int call_initialize_multprec_homotopy ( int *index );
/*
 * DESCRIPTION :
 *   Prepares the containers to initialize the homotopy to track a path
 *   in multiprecision.  Returns in index the number of the
 *   solution in the container selected as start solution. */

int write_standard_solution ( int index );
/*
 * DESCRIPTION :
 *   Writes the solution in the standard solutions container
 *   at position equal to the value of the given index to screen. */

int write_dobldobl_solution ( int index );
/*
 * DESCRIPTION :
 *   Writes the solution in the double double solutions container
 *   at position equal to the value of the given index to screen. */

int write_quaddobl_solution ( int index );
/*
 * DESCRIPTION :
 *   Writes the solution in the quad double solutions container
 *   at position equal to the value of the given index to screen. */

int write_multprec_solution ( int index );
/*
 * DESCRIPTION :
 *   Writes the solution in the multiprecision solutions container
 *   at position equal to the value of the given index to screen. */

int call_standard_path_tracker ( int index );
/*
 * DESCRIPTION :
 *   Calls the path tracker in standard double precision,
 *   starting a solution with the numbers in the index. */

int call_dobldobl_path_tracker ( int index );
/*
 * DESCRIPTION :
 *   Calls the path tracker in double double precision,
 *   starting a solution with the numbers in the index. */

int call_quaddobl_path_tracker ( int index );
/*
 * DESCRIPTION :
 *   Calls the path tracker in quad double precision,
 *   starting a solution with the numbers in the index. */

int call_multprec_path_tracker ( int index );
/*
 * DESCRIPTION :
 *   Calls the path tracker in multiprecision,
 *   starting a solution with the numbers in the index. */

int main ( int argc, char *argv[] )
{
   int fail,nbsol;

   adainit();

   int level = prompt_for_precision();
   if(level == 0)
   {
      fail = call_initialize_standard_homotopy(&nbsol);
      fail = call_standard_path_tracker(nbsol);
      fail = clear_standard_tracker();
   }
   else if(level == 1)
   {
      fail = call_initialize_dobldobl_homotopy(&nbsol);
      fail = call_dobldobl_path_tracker(nbsol);
      fail = clear_dobldobl_tracker();
   }
   else if(level == 2)
   {
      fail = call_initialize_quaddobl_homotopy(&nbsol);
      fail = call_quaddobl_path_tracker(nbsol);
      fail = clear_quaddobl_tracker();
   }
   else
   {
      fail = call_initialize_multprec_homotopy(&nbsol);
      fail = call_multprec_path_tracker(nbsol);
      fail = clear_multprec_tracker();
   }

   adafinal();

   return 0;
}

int prompt_for_precision ( void )
{
   int answer = 0;
   char nlc;

   printf("\n");
   printf("Welcome to the path tracking with generators ...\n");
   printf("  0. run in standard double precision arithmetic;\n");
   printf("  1. run in double double precision arithmetic;\n");
   printf("  2. run in quad double precision arithmetic;\n");
   printf("  3. run in multiprecision arithmetic.\n");
   printf("Type 0, 1, 2, or 3 to select precision : ");
   scanf("%d",&answer);
   scanf("%c",&nlc);     /* skip new line symbol */

   return answer;
}

int call_initialize_standard_homotopy ( int *index )
{
   int fail,len,fixed;

   fail = read_target_system_without_solutions();
   fail = read_standard_start_system();
   fail = copy_start_solutions_to_container();
   fail = solcon_number_of_solutions(&len);
   printf("Number of start solutions : %d\n",len);
   printf("-> give index of solution : "); scanf("%d",index);
   printf("Fixed gamma constant ? (1 = yes/0 = no) "); scanf("%d",&fixed);
   fail = initialize_standard_homotopy(fixed);
   fail = initialize_standard_solution(*index);

   return fail;
}

int call_initialize_dobldobl_homotopy ( int *index )
{
   int fail,len,fixed;

   fail = read_dobldobl_target_system(); /* no _without_solutions ! */
   fail = read_dobldobl_start_system();
   fail = copy_dobldobl_start_solutions_to_container();
   fail = solcon_number_of_dobldobl_solutions(&len);
   printf("Number of start solutions : %d\n",len);
   printf("-> give index of solution : "); scanf("%d",index);
   printf("Fixed gamma constant ? (1 = yes/0 = no) "); scanf("%d",&fixed);
   fail = initialize_dobldobl_homotopy(fixed);
   fail = initialize_dobldobl_solution(*index);

   return fail;
}

int call_initialize_quaddobl_homotopy ( int *index )
{
   int fail,len,fixed;

   fail = read_quaddobl_target_system(); /* no _without_solutions ! */
   fail = read_quaddobl_start_system();
   fail = copy_quaddobl_start_solutions_to_container();
   fail = solcon_number_of_quaddobl_solutions(&len);
   printf("Number of start solutions : %d\n",len);
   printf("-> give index of solution : "); scanf("%d",index);
   printf("Fixed gamma constant ? (1 = yes/0 = no) "); scanf("%d",&fixed);
   fail = initialize_quaddobl_homotopy(fixed);
   fail = initialize_quaddobl_solution(*index);

   return fail;
}

int call_initialize_multprec_homotopy ( int *index )
{
   int fail,len,deci,fixed;
   char nlc;

   printf("\ngive the number of decimal places in the working precision : ");
   scanf("%d",&deci);
   scanf("%c",&nlc);     /* skip new line symbol */

   fail = read_multprec_target_system(deci); /* no _without_solutions ! */
   fail = read_multprec_start_system(deci);
   fail = copy_multprec_start_solutions_to_container();
   fail = solcon_number_of_multprec_solutions(&len);
   printf("Number of start solutions : %d\n",len);
   printf("-> give index of solution : "); scanf("%d",index);
   printf("Fixed gamma constant ? (1 = yes/0 = no) "); scanf("%d",&fixed);
   fail = initialize_multprec_homotopy(fixed,deci);
   fail = initialize_multprec_solution(*index);

   return fail;
}

int write_standard_solution ( int index )
{
   int fail,nb;

   fail = solcon_length_solution_string(index,&nb);
   {
      char solution[nb];

      fail = solcon_write_solution_string(index,nb,solution);
      printf("\nsolution %d :\n%s\n",index,solution);
   }

   return fail;
}

int write_dobldobl_solution ( int index )
{
   int fail,nb;

   fail = solcon_length_dobldobl_solution_string(index,&nb);
   {
      char solution[nb];

      fail = solcon_write_dobldobl_solution_string(index,nb,solution);
      printf("\nsolution %d :\n%s\n",index,solution);
   }

   return fail;
}

int write_quaddobl_solution ( int index )
{
   int fail,nb;

   fail = solcon_length_quaddobl_solution_string(index,&nb);
   {
      char solution[nb];

      fail = solcon_write_quaddobl_solution_string(index,nb,solution);
      printf("\nsolution %d :\n%s\n",index,solution);
   }

   return fail;
}

int write_multprec_solution ( int index )
{
   int fail,nb;

   fail = solcon_length_multprec_solution_string(index,&nb);
   {
      char solution[nb];

      fail = solcon_write_multprec_solution_string(index,nb,solution);
      printf("\nsolution %d :\n%s\n",index,solution);
   }

   return fail;
}

int call_standard_path_tracker ( int index )
{
   int fail;
   char answer;

   fail = write_standard_solution(index);
   do
   {
      fail = next_standard_solution(index);
      fail = write_standard_solution(index);
      printf("Continue to next step ? (y/n) ");
      scanf("%c",&answer); /* get trailing new line...*/
      scanf("%c",&answer);
   }
   while(answer == 'y');

   return fail;
}

int call_dobldobl_path_tracker ( int index )
{
   int fail;
   char answer;

   fail = write_dobldobl_solution(index);
   do
   {
      fail = next_dobldobl_solution(index);
      fail = write_dobldobl_solution(index);
      printf("Continue to next step ? (y/n) ");
      scanf("%c",&answer); /* get trailing new line...*/
      scanf("%c",&answer);
   }
   while(answer == 'y');

   return fail;
}

int call_quaddobl_path_tracker ( int index )
{
   int fail;
   char answer;

   fail = write_quaddobl_solution(index);
   do
   {
      fail = next_quaddobl_solution(index);
      fail = write_quaddobl_solution(index);
      printf("Continue to next step ? (y/n) ");
      scanf("%c",&answer); /* get trailing new line...*/
      scanf("%c",&answer);
   }
   while(answer == 'y');

   return fail;
}

int call_multprec_path_tracker ( int index )
{
   int fail;
   char answer;

   fail = write_multprec_solution(index);
   do
   {
      fail = next_multprec_solution(index);
      fail = write_multprec_solution(index);
      printf("Continue to next step ? (y/n) ");
      scanf("%c",&answer); /* get trailing new line...*/
      scanf("%c",&answer);
   }
   while(answer == 'y');

   return fail;
}
